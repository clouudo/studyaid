-- phpMyAdmin SQL Dump
-- version 5.2.1
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1
-- Generation Time: Oct 30, 2025 at 06:37 AM
-- Server version: 10.4.32-MariaDB
-- PHP Version: 8.2.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `studyaid`
--

-- --------------------------------------------------------

--
-- Table structure for table `file`
--

CREATE TABLE `file` (
  `fileID` int(11) NOT NULL,
  `userID` int(11) NOT NULL,
  `folderID` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `fileType` varchar(255) NOT NULL,
  `fileSize` varchar(255) NOT NULL,
  `extracted_text` mediumtext DEFAULT NULL,
  `filePath` varchar(255) NOT NULL,
  `uploadDate` date NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Dumping data for table `file`
--

INSERT INTO `file` (`fileID`, `userID`, `folderID`, `name`, `fileType`, `fileSize`, `extracted_text`, `filePath`, `uploadDate`) VALUES
(1, 1, 1, 'Research2', 'docx', '', 'PHPWord\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nStudyAid: AI Summarizer, AI Note, and AI Mindmap\n\r\n\r\n\r\n\r\nBy\n\r\n\r\n\r\n\r\n\r\nYeoh Man Tik\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n							     \n\r\n\r\n	\n\r\n\r\nFACULTY OF COMPUTING AND \n\r\nINFORMATION TECHNOLOGY\n\r\n\r\nTUNKU ABDUL RAHMAN UNIVERSITY OF MANAGEMENT AND TECHNOLOGY\n\r\nKUALA LUMPUR\n\r\n\r\n\r\nACADEMIC YEAR\n\r\n2025/2026\n\r\n\r\n\r\n\r\n\r\n\r\nStudyAid\n\r\n\r\nBy\n\r\n\r\nYeoh Man Tik\n\r\n\r\n\r\nSupervisor: Dr. Lim Fung Ji\n\r\n\r\n\r\n\r\nA project report submitted to the \n\r\nFaculty of Computing and Information Technology  \n\r\nin partial fulfillment of the requirement for the\n\r\nChoose an item.\n\r\n\r\n\r\n\r\nChoose an item.\n\r\nFaculty of Computing and Information Technology  \n\r\nTunku Abdul Rahman University of Management and Technology\n\r\nKuala Lumpur\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCopyright by Tunku Abdul Rahman University of Management and Technology.\n\r\nAll rights reserved.  No part of this project documentation may be reproduced, stored in retrieval system, or transmitted in any form or by any means without prior permission of Tunku Abdul Rahman University of Management and Technology.\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\n\r\nDeclaration\n\r\nThe project submitted herewith is a result of my own efforts in totality and in every aspect of the project works.  All information that has been obtained from other sources had been fully acknowledged.  I understand that any plagiarism, cheating or collusion or any sorts constitutes a breach of TAR University  rules and regulations and would be subjected to disciplinary actions.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n__________________________\n\r\nYeoh Man TIk\n\r\nChoose an item.\n\r\n	ID: 24WMR09322\n\r\n	\n\r\n\r\n\r\nAbstract\n\r\nThe StudyAid project has been developed to address the challenges that students and educators face when processing and understanding diverse types of study materials. The system aims to improve learning efficiency by tackling common problems such as poor knowledge retention, overreliance on passive reading and short-term memorization, and the impact of digital distractions.\n\r\nThe primary solution focuses on AI-powered learning enhancement features that leverage large language models (LLMs) to transform how students interact with their materials. The core functionality includes an intelligent summarization module that automatically generates concise summaries from input content, a structured note-taking system that organizes key information, and mind map generation that offers visual learning aids by representing concepts and their relationships. These AI-driven features are designed to simplify complex learning content, enhance organization, and improve knowledge retention.\n\r\nTo support comprehensive material processing, the platform handles various file formats including digital documents such as PDFs, PPTX, and DOCX through specialized PHP libraries. Additionally, the system incorporates Optical Character Recognition (OCR) using Tesseract as a secondary feature to extract text from images, handwritten notes, and scanned materials, ensuring that all types of study content can be processed and utilized by the AI components.\n\r\nBy prioritizing AI-powered summarization, note organization, and visual representation while providing robust document processing capabilities, StudyAid empowers students and educators to better understand, retain, and interact with their materials through intelligent content transformation rather than passive consumption.\n\r\n\r\n\r\nAcknowledgement\n\r\nThis contains acknowledgement to those who have contributed directly or indirectly to the completion of the project. Usually the people to be acknowledged include the project supervisor(s), moderators, family, and those who have given assistance and support to ensure the success of the project.\n\r\n\r\n\r\nTable of Contents\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChapter 1\n\r\n\r\nIntroduction\n\r\n&#160;\r\n\r\n\r\nIntroduction\n\r\n\r\nThis chapter provides an overall introduction and an overview of AI Summarizer, AI Note and AI Mindmap of StudyAid. It includes background, problem statement, objective, advantages &amp; contributions, project plan, and project team &amp; organization.\n\r\n1.1 Background\r\nThe reliance on digital and physical study materials is rapidly growing among today’s students and educators, with more individuals seeking flexible and efficient ways to obtain and acquire knowledge. Whether through printed lecture notes, handwritten materials, or digital documents, individuals often face challenges in organizing, processing, and understanding vast volumes of content. \n\r\nIn Malaysia, the education sector has witnessed a growing use of online learning platforms and digital materials, especially following the widespread adoption of hybrid and remote learning. Despite these advancements, there remains a lack of intelligent systems that can actively assist in interpreting, simplifying and organizing unstructured content such as handwritten notes, lecture slides, and lengthy documents.\n\r\nThese challenges highlight the urgent need for an integrated solution that can extract, organize, and simplify study materials using intelligent technology. The following section discusses how the proposed StudyAid system addresses this gap by leveraging AI technologies and techniques to enhance the overall study experience.\n\r\n1.2 Problem Statements\r\nKnowledge retention, which refers to the ability to recall information or skills after an initial learning period, has become increasingly difficult for students due to a variety of modern challenges. Research has shown that multitasking with electronic devices such as smartphones and laptops during lectures negatively impacts both learning outcomes and long-term retention (Aaron &amp; Lipton, 2018). However, the issue extends beyond digital distraction. Factors such as a lack of motivation, insufficient desire to learn, and difficulty in comprehending study material also contribute significantly to poor retention (Fatima &amp; Fatima, 2024). When students are faced with an overwhelming volume of content without a clear structure or prioritization, they often experience cognitive overload—a condition where the brain is unable to effectively process and store information. This overload, intensified by constant notifications and digital noise, diminishes focus and hampers the encoding of information into memory (Teachersguide, 2024), highlighting the urgent need for structured, concise learning aids to streamline academic content for better understanding and retention.\n\r\nTraditional learning methods have further compounded the issue by encouraging passive reading habits, where students merely skim through material without meaningful engagement. This superficial approach to learning, which often involves rushing through texts, results in poor recall and reduced comprehension (Dewan, 2019). Without active engagement techniques such as summarizing, questioning, or applying knowledge, information fails to transition from short-term to long-term memory. Additionally, frequent exposure to social media and multitasking during study sessions impairs short-term memory recall and undermines essential cognitive processes (Carr et al., 2020). According to Ebbinghaus’s forgetting curve theory, information is quickly lost over time without deliberate efforts to retain it (Gupta, 2024), emphasizing the need for study methods that incorporate consistent practice and retrieval.\n\r\nDigital distractions have also played a critical role in declining student engagement. With screen-centric behaviors becoming the norm, many students find it difficult to maintain attention during learning activities. A report from the Pew Research Center revealed that 58% of teenagers struggle to stay focused on reading for more than 30 minutes (Anderson &amp; Anderson, 2024). This growing issue reflects a broader decline in attention spans and underscores the need for interactive and stimulating educational tools that can hold students&#039; attention and foster deep learning.\n\r\n1.3 Solution\r\nThe integration of artificial intelligence (AI) in the system is to address the growing challenges faced by students. It will help students actively engage with their study materials and support their studying experience through the following AI-powered features: AI Summarizer, AI Note-taking and AI mind map generation.\n\r\nThe AI summarizer feature targets the inefficiency of passive reading by converting dense, lengthy materials into concise summaries. These summaries distill the most relevant information, making it easier for students to digest complex topics and revisit key points quickly. At the same time, eliminating cognitive overload caused by scattered or unstructured information. This directly tackles the issue of students feeling overwhelmed by large volumes of content and helps them focus on the key concepts necessary for comprehension and retention.\n\r\nTo further enhance comprehension and recall, the system generates structured study notes from the processed material. These notes break down content into digestible points, supporting consistent knowledge reinforcement and active learning strategies such as review and repetition both proven to strengthen memory retention, as highlighted in the Ebbinghaus forgetting curve.\n\r\nIn response to the lack of attention span crisis, AI generated mind maps are used to provide an interactive, visual format of the study material. These maps help students visualize the relationships between concepts, promoting meaningful engagement and aiding memory recall. By presenting content in a format that stimulates both visual and cognitive processes, the tool combats digital distractions and improves focus during study sessions.\n\r\nFinally, StudyAid ensures that all learning outputs such as summaries, notes, and mind maps can be exported for later review. This supports continuous knowledge reinforcement and ensures that progress is not lost when the system is unavailable to use or experiencing downtime, which are crucial when students need to retrieve in an offline environment in order to revise the content. \n\r\nIn conclusion, StudyAid directly addresses the core learning challenges highlighted in recent research by offering a smart, structured, and interactive learning environment. Rather than overwhelming users with raw information, it simplifies and organizes content in ways that promote clarity, focus, engagement, and long-term retention.\n\r\n1.4 Target Audience\r\n1.4.1 Students\r\nFor students, the system serves as a personalized study companion. Viable for students who often struggle with dense course materials, limited opportunities to approach their instructors outside of class hours. StudyAid targets undergraduates and postgraduates who need immediate clarification of complex topics and structured feedback to optimize their study habits.\n\r\n\r\nThe system also supports diverse learning styles by offering visual mind maps, comprehensible summaries, and structured notes that accommodate both visual and verbal learners. In addition, it benefits students with attention difficulties or learning challenges by simplifying and organizing content into accessible, well-structured formats. Additionally, students preparing for competitive exams can use StudyAid to enhance traditional learning methods at a personal pace.\n\r\n1.4.2 Educators\r\nEducators, including lecturers and teaching assistants form another portion of the target audience. They benefit from StudyAid&#039;s features that enhance instruction and support personalized learning. For example, lecturers can recommend the system as a supplementary tool for students who struggle with particular topics, enabling deeper understanding outside of the classroom.\n\r\n\r\nMoreover, StudyAid can be integrated into teaching workflows. Features such as student performance tracking and analytics allow educators to gain insights into students’ learning progress. A lecturer, for instance, can review topic-specific student performance data to identify areas where multiple students underperform and revise lesson content.\n\r\n1.5 Objectives\r\nThe following are the objectives that were determined for the system to solve the following problems:\n\r\nDevelop AI Integrated Functionalities\n\r\n: Integrate AI functionalities, specifically a summarizer, note-taking tool, and mind map generator, achieving a functional prototype for each feature that processes and generates outputs for at least 90% of typical study materials, utilizing existing AI Large Language Models, to enhance learning experiences, with full development and integration within six months.\n\r\n&nbsp;\n\r\n\r\nCreate a User-Friendly Interface\n\r\n: Design and develop a user-friendly interface allowing easy upload of study materials and receiving of AI-generated summaries, notes, and mind maps, by employing modern web development frameworks and UX design principles, to ensure user friendliness and user engagement, with completion of design, development, and testing within five months.\n\r\n\r\n&#160;\r\n\r\n\r\n1.6 Strength &amp; Limitations\r\n1.6.1 Personalized &amp; Adaptive Learning\r\nStudyAid provides a tailored learning environment to students. The implementation of Artificial Intelligence (AI) powered features allows the system to dynamically adjust content based on the requirements of individuals.  Adaptive learning systems can adapt to the subject of content, pace, and the type of output based on feedback from individual interactions with the system.  A case study with an AI tutor built using GPT-3 showed students improvement up to 15 percentile points compared to peers without AI assistance. (Baillifard et al., 2023)\n\r\n1.6.2 Enhanced Engagement of Study Materials\r\nStudyAid provides adaptive tools that adjust pacing and provide interactive feedback that further activate individual&#039;s interest in the learning process. It encourages individual-centered learning where they have greater control of their learning path and process. \n\r\nIndividuals are able to advance learning at their own pace through StudyAid which encourages autonomy and competence through specificity of what suits the individual&#039;s preferred pace of learning. \n\r\n1.6.3 Support for Educators \r\nFor educators, StudyAid provides an opportunity to reinforce classroom instruction with intelligent tools that enable deeper understanding outside of the lecture hall. Teachers can recommend the tool to help students grasp difficult topics more easily, reinforce key learning points, and cultivate better self-directed learning habits. This bridges the gap between teaching and independent study, enabling more personalized and effective learning experiences.\n\r\n1.6.4 AI Functionalities Disabled If API Provider Down\r\nOne noticeable limitation of StudyAid is the system&#039;s dependency on third-party AI large language model (LLM) APIs. If an external AI provider experiences downtime, service degradation or becomes unavailable, key features like summarization, note generation and mind map creation will become non-functional. \n\r\n1.6.5 Token &amp; Usage Limitations\r\nDue to the dependency on third-party AI LLM there will be limits on the usage of StudyAid&#039;s various AI features. The token and usage limit set by third-party AI LLM was to optimize their computation resource and prevent overuse. Hence, a limiter has to be implemented from using AI integrated functionalities of StudyAid. \n\r\n1.7 Development Plan\r\n1.7.1 Development Schedule\r\nTable 1.1: Project Schedule\n\r\n\r\n\r\n\r\nACTIVITIES\n\r\n\r\n\r\nGOAL\n\r\n\r\n\r\nCOMPLETION DATE\n\r\n\r\n\r\n\r\n\r\nProject Title Discussion\n\r\n\r\n\r\nFinalized project title and established objectives for the title.\n\r\n\r\n\r\n27/3/2025\n\r\n\r\n\r\n\r\n\r\nDiscussion of proposal\n\r\n\r\n\r\nCarry out research and searching to produce a feasible plan and proposal draft.\n\r\n\r\n\r\n3/4/2025\n\r\n\r\n\r\n\r\n\r\nWriting the proposal\n\r\n\r\n\r\nProposal is ready to be submitted and reviewed.\n\r\n\r\n\r\n16/4/2025\n\r\n\r\n\r\n\r\n\r\nIntroduction\n\r\n\r\n\r\nCarry out research about the finalized proposed functions and features to have a deep understanding about the project.\n\r\n\r\n\r\n30/6/2025\n\r\n\r\n\r\n\r\n\r\nResearch Background\n\r\n\r\n\r\nReview papers in academia to discover findings related to the project to produce a thorough literature review.\n\r\n\r\n\r\n14/07/2025\n\r\n\r\n\r\n\r\n\r\nMethodology and Requirement Analysis\n\r\n\r\n\r\nProduce an executive plan before the commencement of the software development phase.\n\r\n\r\n\r\n28/07/2025\n\r\n\r\n\r\n\r\n\r\nSystem Design\n\r\n\r\n\r\nDesign system, UI, data, report, security, process, system architecture and algorithm.\n\r\n\r\n\r\n18/08/2025\n\r\n\r\n\r\n\r\n\r\nFYP1 Report &amp; Presentation\n\r\n\r\n\r\nCompile progress, submit FYP1 report, and present\n\r\n\r\n\r\n26/09/2025\n\r\n\r\n\r\n\r\n\r\nDevelopment and Implementation\n\r\n\r\n\r\nDocuments implementation of the project and develops the system. Lastly, carry out integration of modules, ensuring modules can work with each other seamlessly.\n\r\n\r\n\r\n5/10/2025\n\r\n\r\n\r\n\r\n\r\nTesting &amp; Deployment\n\r\n\r\n\r\nCreation of test cases and begin testing and deployment of software.\n\r\n\r\n\r\n21/11/2025\n\r\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n1.7.2 Gantt Chart\r\n\r\nFigure 1.1: Gantt Chart - Proposal Stage\n\r\n\r\nFigure 1.2: Gantt Chart - Final Year Project 1\n\r\n\r\nFigure 1.3: Gantt Chart - Final Year Project 1\n\r\n\r\nFigure 1.4: Gantt Chart - Final Year Project 1 &amp; Final Year Project 2\n\r\n\r\nFigure 1.5:  Gantt Chart - Final Year Project 2\n\r\n\r\n&#160;\r\n\r\n\r\n1.8 Project Team &amp; Organization\r\nTable 1.2 Project Organization Table\n\r\n\r\n1.9 Chapter Summary and Evaluation\r\n\r\n\r\nThis chapter presents StudyAid, an AI-driven educational system aimed at improving knowledge retention and engagement in the digital learning landscape. The system addresses issues such as cognitive overload, passive reading, reduced attention spans, and digital distractions that hinder educational outcomes. StudyAid provides a comprehensive solution through three primary AI features: an AI Summarizer for concise material summaries, AI Note-taking for structured notes, and AI Mind Map generation for visual learning aids. Designed for both students and educators, the system seeks to offer personalized learning experiences while accommodating various learning styles and facilitating continuous knowledge reinforcement through exportable outputs. The development plan details a six-month timeline for creating a user-friendly interface and functional prototype, with a project team organized into specialized modules for content management, learning material processing, user management, and performance analysis to create a complete educational support platform.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChapter 2\n\r\nLiterature Review\n\r\n&#160;\r\n\r\n\r\nLiterature Review\n\r\n\r\nThis section reviews existing studies, technologies, and tools relevant to the development of the StudyAid system. The purpose of this literature review is to establish a foundation of understanding for the project by analyzing current research and identifying trends in the fields of Artificial Intelligence (AI), methodology and etcetera.\n\r\n2.1 Agile Methodology\r\n\r\nFigure 2.1 Agile Methodology (Oclarit et al., 2024)\n\r\n\r\nAgile refers to the ability to move quickly and efficiently which describes software development methods that aim to meet the growing demand from businesses for faster, more adaptable, and lightweight development processes. (Abrahamsson et al., 2017).\n\r\n\r\nAdopting Agile Methodology in software development offers numerous benefits including rapid delivery of product, highly tolerant of change requirements, reduced cost and time, avoids over production and ensures customer satisfaction. (Suppiah et al., 2016). \n\r\n\r\nAccording to a research paper, Agile practices are suitable for IoT development and can play an important role in achieving successful projects. One of the benefits mentioned include Agile encourages balanced team dynamics, valuing both soft and technical skills for success. (Van Bolhuis et al., 2022).\n\r\n2.2.2 Kanban\r\n\r\nFigure 2.3 Sample Kanban Board (GeeksforGeeks, 2024)\n\r\nOriginating from Japan, the term Kanban is linked to the &quot;just-in-time&quot; production concept. This method involves using a Kanban board, which is divided into columns to represent different stages of a workflow. Tasks are visualized as cards that move across these columns as progress is made. When a new task is created, a new card is added to the board.\n\r\nKanban promotes transparency and collaboration by giving team members and stakeholders a clear view of the project’s current status at any moment. It emphasizes managing team workload, making it particularly effective for iterations involving several small changes. Beyond software development, Kanban is also valuable in areas like human resources and marketing, where it enhances task visibility and coordination across teams. (Ashtari, 2022)	\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n2.2.3 Scrum\r\n\r\nFigure 2.4 Scrum Process (S, 2025)\n\r\n\r\nScrum as an Agile framework is one of the most popular approaches to software development. It refines Agile principles into a well-defined and structured framework. It outlines clear roles: Product Owner, Scrum Master, and Development Team. Whereas its key artifacts include Product Backlog, Sprint Backlog, and Increment. It also introduces core events including Sprint Planning, Daily Scrum, Sprint Review, and Sprint Retrospective to effectively guide teams through the product development cycle. \n\r\n\r\nThe Scrum framework places strong emphasis on collaboration, responsibility, and iterative progress toward clearly defined objectives, making it especially suitable for handling complex projects. (Dada, n.d.).\n\r\n2.2.4 Extreme Programming (XP)\r\nExtreme Programming (XP) is another agile software development methodology that aims to improve the quality and responsiveness of software development projects. This methodology was born out of frustration with the traditional waterfall software development model which often resulted in long development cycles and frequent budget overruns. There are five core values of Extreme Programming which include communication, simplicity, feedback, courage and respect. (Extreme Programming (XP): Revolutionizing Software Development, 2023)\n\r\n\r\nAdopting Extreme Programming in software development offers various benefits including, enhanced team collaboration and improved product quality. (Extreme Programming Misconceptions, n.d.) \n\r\n2.2 Requirement Analysis\r\nIn software engineering, requirement elicitation techniques are vital for accurately defining a system&#039;s functional requirements which refers to what a system must do and the non-functional requirements which defines how it must perform. These techniques are used to ensure alignment with stakeholder needs and business objectives, reduce rework, and support traceability and compliance.\n\r\n2.2.1 Viewpoint-oriented Analysis\r\nViewpoint-oriented analysis is a method in software requirements engineering that involves identifying and analyzing the perspectives of various stakeholders, referred to as viewpoints. This approach is particularly useful in large-scale software projects where multiple stakeholders with diverse needs are involved. (Pu &amp; Liu, 2009)\n\r\n\r\nUsing this approach helps manage and resolve conflicts between requirements from different viewpoints, leading to a more balanced and harmonious requirements set. (Pu &amp; Liu, 2009). The use of structured approach to viewpoint integration enhances the consistency and coherence of the requirements documentation. (Wang, 2007)\n\r\n\r\nThis approach is particularly useful in projects involving numerous stakeholders with varying requirements, such as enterprise software systems. (Araújo &amp; Coutinho, 2003). Systems where certain requirements affect multiple components or modules, necessitating a method to manage these cross cutting concerns effectively. (Lee &amp; Yoo, 2013)\n\r\n\r\nViewpoint-oriented Analysis captures the interactions between users and the system, supporting the development of use case models, which are crucial for understanding system functionality. (Wang, 2007) The approach aids in organizing and managing requirements, making it easier to track changes and ensure alignment with stakeholder needs. (Pu &amp; Liu, 2009)\n\r\n\r\n\r\n\r\n2.2.2 Joint Application Design\r\nJAD is a structured, workshop-driven technique, designed to bring together stakeholders into collaborative sessions to define and specify software requirements as a group. Originating at IBM in the late 1970s, it was created to speed up development and enhance system acceptance by involving users directly in the design process. (Awati, 2023).\n\r\n\r\nJAD begins by defining the project. This phase requires briefing the purpose of the JAD meeting, such as whether to gather requirements for a new project, modify an existing project, and etcetera. \n\r\n\r\nThe next stage proceeds with understanding user requirements. This phase involves identification of data, processes, system requirements and developing a system prototype based on a generic model that serves as a working model.\n\r\n\r\nMoreover, the preparation phase includes scheduling sessions, selecting stakeholders, making arrangements such as acquiring materials and directing related activities. This phase also includes kick-off meetings or an orientation.\n\r\n\r\nConducting and facilitating the actual session include carrying out effective meetings that rely heavily on thorough preparation and the facilitator&#039;s ability to guide the group toward meeting all objectives and reaching clear, actionable outcomes.\n\r\n\r\nLastly, follow up documentation is conducted. The last phase involves creating and distributing a comprehensive summary of the outcomes. The modeler compiles a finalized design document, obtains approval from the executive sponsor, and ensures it is shared with all participants. (N Nayab, 2011).\n\r\n2.2.3 Fact Gathering\r\nInterviews (Structured &amp; Unstructured)\n\r\n\r\nInterviews consist of direct face-to-face communication with stakeholders to explore and analyse their requirements and expectations. They can be conducted in a structured format by using a predetermined list of questions or in an unstructured manner that is more informal and open-ended. This method is effective in uncovering detailed insights into each stakeholder’s viewpoint. (Staff, 2024)\n\r\n\r\n\r\n\r\nObservation\n\r\n\r\nObservation can be either passive or active. Active observation requires asking questions of users while observing them. It is the most effective approach for gaining an understanding of an existing process. Whereas passive observation is more effective when gathering user feedback on a design prototype. Observing end users in real context will help you gain true understanding of what problems they are experiencing and what improvements are needed so they can perform effectively. (Jama Software, 2024)\n\r\nDocument analysis\n\r\n\r\nBy examining the documentation of an existing system, you can perform AS-IS process analysis to identify opportunities for improvement, and gap analysis to pinpoint areas where current business needs are not being met. These gaps often become evident when compared to insights obtained through interviews, surveys, or user observations.\n\r\nWhile it’s important to review the system’s requirements documents (if available), it’s equally valuable to explore other related materials, such as user manuals and issue logs. These documents often contain hidden insights explaining why certain functionalities exist or how specific design decisions were made.\n\r\nThe findings from document analysis can spark new questions and help assess whether your current set of requirements is complete. (Jama Software, 2024).\n\r\nKnowledge Reuse\n\r\n\r\nKnowledge reuse as a software requirement technique involves leveraging existing knowledge patterns and artifacts to streamline requirements engineering processes. This technique is particularly beneficial in iterative software development environments where similar requirements recur across projects.\n\r\n\r\nReusing software artifacts reduces the overall development costs and accelerates the development process by eliminating the need to create requirements from scratch. (Bolanle &amp; Isaac, 2014) Reused requirements often come with proven properties, which can enhance the reliability and quality of software being developed. (Ahmad et al., 2020) The reuse of established requirements reduces the risk associated with the requirements engineering process, as these requirements have been validated in previous projects. (Bolanle &amp; Isaac, 2014)\n\r\n\r\nKnowledge reuse is particularly effective in domains where software systems share common functionalities, such as enterprise resource planning (ERP) systems, or customer relationship management (CRM) systems. In these cases, requirements can be reused across different projects within the same domain. (Bolanle &amp; Isaac, 2014) Reuse of use case patterns during the requirements capture phase allows for a clear visualization of the system to be implemented and facilitates normalization in the requirements process. (Silveira &amp; Vidal, 2002) \n\r\n2.3 Design Strategy \r\n2.3.1 Object-Oriented Design\r\nObject-oriented Design (OOD) is a widely adopted software design strategy that decomposes a system into a structure of interacting objects, which are instances of classes and that encapsulate both data and behaviors. This design approach emphasizes key quality attributes including modularity, adaptability, reusability and maintainability. \n\r\n\r\nThe fundamental premise of OOD is the centrality of objects in both problem and solution domains. According to OOD advocates like Meyer (1988) and Rosson &amp; Alpert (1990), OOD offers a natural, ease of use and intuitive mapping between real-world entities and software representations. (Chatel &amp; Détienne, 2007)\n\r\n\r\nHowever, OOD does not only have strengths but it also comes with a set of drawbacks such as OOD cannot be effectively adopted if programmers have insufficient training, resulting in missed deadlines. More issues may arise when timelines are shortened in expectation of OOD&#039;s promise of speed. In addition, OOD is not the most appropriate choice for every requirement; it is only suitable for systems with large amounts of graphics, interfaces and databases. (Teresa, 2018)\n\r\nIn conclusion, Object-Oriented Design offers clear benefits in modularity and reusability, especially for complex systems. However, its effectiveness depends on developer expertise and project suitability, making it important to apply OOD where it best fits the context.\n\r\n2.3.2 Functional-Oriented Design &amp; Function-Class Decomposition\r\nFunctional-Oriented Design (FOD) is defined as a top-down design method that decomposes a system into modules based on distinct functions. It uses common tools like data flow diagrams, data dictionaries, structure charts, and pseudo code to guide decomposition and ensure module reusability. \n\r\n\r\nFunction-Class Decomposition (FCD) is a hybrid approach that combines functional decomposition from FOD with Object-Oriented Design. It provides clear mapping of requirements to design hierarchy. Leaf nodes represent primitive components, changes in the leaf nodes are localized. Higher-level nodes represent functional modules, which indicates changes within show broader impact. The clarity here improves the impact analysis and change management. However, FOD also requires extra work and discipline. The decomposition process of the system demands more effort and careful planning. Grouping classes into functional modules is time-consuming and non-trivial. (Chang et al., 2001)\n\r\n2.4 Architecture Patterns\r\n2.4.1 Model-View-Controller\r\nModel-View-Controller (MVC) is a software architecture pattern that breaks up software applications into three interconnected components, including Model, View, and Controller. Each of these components play a specific role, emphasizing on the principle of clear separation of concern and the importance of code reusability.\n\r\n\r\nMVC promotes the specialization of development tasks. For instance, developers with expertise in building user interfaces can focus solely on the View, while those working on Model classes can concentrate on the application&#039;s core logic without worrying about the interface.\n\r\n	\n\r\nAnother advantage of MVC is that Model classes can be reused across multiple Views. For example, a model containing hour and minute values can be displayed in various formats, such as analog clock or digital clock. (Valente, n.d.)\n\r\n\r\nSome of the most widely used MVC frameworks include Backbone.js, AngularJS, Ember, KnockoutJS, Vue.js, React, Django, CodeIgniter, and Laravel (Cubet, n.d.). These frameworks provide structured approaches to application development, promoting separation of concerns, improving code maintainability, and enabling more efficient collaboration among developers across the front-end and back-end components. (Cubet, n.d.).\n\r\n2.4.2 Layered Architecture\r\nLayered architecture or layered pattern is a software architecture pattern that structures an application into well defined layers that serves a specific responsibility. The bottom layer consists of objects that perform low-level functions. The following layer performs higher functionality and calls to objects in the lower layers. The purpose of layering is to abstract details needed to perform the function from higher level objects simply by delegating them to lower levels. Object calls are always downward in layered architecture. (Rana &amp; Saleh, 2022).\n\r\n\r\nLayered architecture offers several advantages that makes it a popular and widely adopted software architecture pattern. It offers strong modularity and separation of concerns by separating each layer with specific functionality. This separation allows different parts of the system to be developed, tested, and maintained independently, making the overall codebase easier to manage and understand.\n\r\n\r\nMoreover, the loosely coupled nature of the layers supports scalability, enabling developers to introduce new features or restructure the system by adding or modifying layers without overhauling the entire application. Layered architecture also encourages code reuse. Each layer with well-defined roles can be extracted and reused in other projects, reducing redundancy and improving development efficiency. (Tu, 2023).\n\r\n2.4.3 Client-Server \r\nClient-server architecture is a computing model in which one computer, known as the client, requests resources or services from another computer, called the server, through a network connection. The server plays the role of processing these requests and sends the appropriate responses back to the client. This model typically involves multiple clients interacting with one or more servers that work together to handle the requests.\n\r\n\r\nThe communication between client and server is enabled through standardized protocols such as Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP) and Simple Mail Transfer Protocol (SMTP). \n\r\n	\n\r\nSince its introduction, client-server architecture has led to numerous advancements that have enhanced collaboration and resource sharing management. One of its key strengths is the ability to store data centrally while allowing remote access by client computers located anywhere in the world. This means that server resources can be accessed globally, enabling greater flexibility and connectivity. (Cimen et al., 2014)\n\r\n\r\nThe architecture also supports scalability, as additional resources or servers can be integrated easily and accessed from various locations. (Rana &amp; Saleh, 2022). This improves processing capabilities and minimizes response time while handling client requests. Centralized resource management reduces maintenance costs and simplifies administration.\n\r\n\r\nFurthermore, client-server architecture enables effective load balancing by allowing the use of redundant or replica servers to distribute workload evenly. This not only enhances performance but also improves system reliability and recovery in case of server failure (Guynes &amp; Windsor, 2011).\n\r\n\r\nOn the other hand, there are also disadvantages from using client-server architecture that may hinder its implementation if not considered and managed. A major concern is ensuring the security of shared resources. Because all data is stored centrally, any disruption in the network connection between the client and server can limit or prevent access to resources.\n\r\n\r\nMoreover, if the server experiences technical issues, client devices will be unable to connect or retrieve data. This architecture is also vulnerable to cyber threats such as Denial of Service (DoS) attacks, which can block access to server resources and Man-in-the-Middle attacks, which can intercept and later data in transit between the client and server. (Chahal et al., 2019).\n\r\n2.5 Testing Techniques and Methods\r\n2.5.1 White Box Testing Levels\r\nWhite-box testing is a comprehensive and detailed approach to software testing that focuses on evaluating the internal logic, structure of an application. It involves having full access to the software&#039;s source code and design documentation, enabling software testers to thoroughly examine its internal operations, system flow and integration points.\n\r\n\r\nUnit Testing\n\r\n\r\nUnit testing is a white-box testing technique where individual units or components of a software application are tested in isolation to ensure that they function as intended. With the increasing complexity of modern software across various critical sectors, unit testing has become a standard and often essential practice, serving as a foundation for ensuring software quality and reliability.\n\r\n		\n\r\nAccording to research about unit testing in practice, it was found that unit testing was crucial and should be included in the process of software project development. It has detected errors during unit testing that other testing methods missed. This shows that unit testing addresses gaps left by other forms of testing. Thus, it should not be eliminated from the development process. (Ellims et al., 2004)\n\r\n\r\nHowever, unit tests come with a set of drawbacks that software testers may need to consider before performing. Although useful, unit tests can be hard to maintain throughout a project&#039;s lifecycle. A practical strategy is required to balance unit testing with business pressures. Unit testing is not always the most suitable method as in one project (Grommet), even with 95%, bugs still appeared, proving that high coverage doesn&#039;t guarantee quality. Instead, techniques like boundary values analysis and domain testing were more effective. (Ellims et al., 2004)\n\r\nIntegration Testing\n\r\n\r\nIntegration testing evaluates how independently-tested modules work together when integrated to form a larger module or full system. This testing technique is performed to verify if  software system components maintain or retain the same behavior when integrated with other components. Two widely used integration testing approaches are bottom-up testing approach and top-down testing approach. Bottom-up testing approach evaluates low level system modules before testing it with higher level modules. The top-down testing approach is the opposite of the bottom-up testing approach.\n\r\nIntegration testing plays a vital role in improving software quality by systematically verifying interactions between components, particularly at integration points where issues are most likely to arise. These areas often reveal hidden defects within the system. Integration testing helps identify flaws in module interactions, ensures data consistency across components, enables early detection of interface issues, and streamlines the deployment process through thorough and comprehensive testing. (Crudu, 2025)\n\r\n2.5.2 Black Box Testing Techniques\r\nBlack-box testing is a method of software testing that examines the functionality of an application without peering into its internal structures or workings. A tester provides an input, and observes the output generated by the system under test, focusing solely on validating whether the software meets its specified requirements and behaves correctly from an end-user perspective. This approach makes it possible to identify how the system responds to expected and unexpected user actions and can be applied at various testing levels. Black-box testing is particularly valuable because it simulates real user interactions and helps ensure the software delivers the intended functionality regardless of its underlying technical implementation.\n\r\n\r\n\r\n\r\nDecision Table Testing\n\r\n\r\nDecision table testing is a structured black-box testing method used in software testing to validate complex business rules and logic. It organizes various input combinations and their expected outcomes into a tabular format known as a decision table. Each column in the table represents a specific rule which is a unique combination of both input conditions and the corresponding system response or action.\n\r\nThe key reason for using decision tables is their ability to handle complex combinations of inputs that lead to different actions or event sequences which techniques like boundary value analysis and equivalence partitioning struggle with. While those methods are effective for testing specific conditions or input ranges, they fall short when it comes to managing intricate business rules involving multiple input combinations. Decision tables address this limitation by providing a comprehensive and structured way to represent and test such complex scenarios. (Professionalqa.com, n.d.)\n\r\nCause-Effect Graph\n\r\n\r\nCause-Effect Graphing (CEG) originated as a hardware testing approach and was later adapted and further developed for use in software testing. It is a black-box testing technique that focuses solely on the external behavior of a system without considering its internal structure. Unlike other black-box methods, CEG specifically addresses combinations of input conditions which are referred to as “causes” and “effects”  that lead to specific system responses.\n\r\nIn this context, a cause is any condition or input described in the requirements that may influence the system&#039;s behavior, while an effect is the system’s response to one or more input conditions. Notably, an effect in one scenario can also function as a cause for another effect.\n\r\nThe standard process for generating tests through CEG includes reading the system requirements to identify and label all causes and effects, representing their relationships through the cause-effect graph, transforming that graph into a decision table, and then generating test cases from the table. To identify effects effectively, testers are advised to carefully examine the specification or related documentation, highlighting words or phrases that describe outputs or transformations within the system.\n\r\nThis method supports dependency modeling and helps avoid test case explosion by applying specific heuristics during test case generation, making it a practical choice for testing systems with complex input-output relationships. (Srivastava et al., 2009)\n\r\nState Transition Testing\n\r\n\r\nState Transition Testing (STT) focuses on validating the behavior of a system as it transitions between different states. This approach ensures all possible transitions are tested, thereby enhancing the reliability and functionality of software applications. It involves identifying states, creating transition diagrams, determining test cases for transitions, and analyzing results to ensure proper functionality in various scenarios. The implementation and use of Black Box Testing technique using STT is able to improve system quality and provide a better user experience. (Salim &amp; Rusdiansyah, 2025)\n\r\n2.6 Existing Technologies\r\n2.6.1 Optical Character Recognition (OCR)\n\r\n\r\nOptical Character Recognition (OCR) is a technology for transforming printed or handwritten texts into digital format characters. This technology has various applications across different industries, which include digitization of handwritten documents, text analysis, and accessibility features. \n\r\n\r\nOCR technology has come a long way, it evolved from being developed using basic techniques to current advanced AI-driven methods. Early OCR systems relied on traditional algorithms and approaches like template matching and feature-based extraction methods. Hence, they were limited in their ability to handle complex layouts and diverse text types. However, with the introduction of deep learning, models such as Convolutional Neural Networks (CNNs), Recurrent Neural Networks (RNNs), and Transformer-based architectures have revolutionized OCR capabilities. These models excel in recognizing text from complex scenes and handling multiple languages, making them highly versatile for real-world applications. (Mishra et al., 2024)\n\r\n\r\nOCR plays a crucial role in providing accessibility and assisting visually impaired individuals by converting printed or handwritten text into digital formats that can be broadcasted or narrated using text-to-speech technologies. (Jain &amp; Gupta, 2024)\n\r\n\r\nMoreover, OCR is widely used for converting large volumes of printed or scanned documents into digital format. This improves storage time and reduces the workload required for manually analyzing and documenting physical documents into digital format. OCR has been particularly useful in digitizing historical archives and automating data entry processes. (Singh et al., 2024)  \n\r\nTable 2.1 Comparison of OCR Tools\n\r\n\r\n&#160;\r\n \n\r\n\r\n2.6.2 Large Language Models (LLMs)\r\nLarge Language Models (LLMs) are advanced deep learning algorithms developed to analyze, understand, prompt and generate human language. They are built using neural networks and utilize transformer-based architectures, which allow them to process vast amounts of text data and perform a variety of language-related tasks. The introduction of these models have revolutionized fields such as natural language processing (NLP), Artificial Intelligence (AI) assistants, translation, and software development by providing efficient and accurate text analysis and generation.\n\r\n\r\nFigure 2.5 Transformer Architecture (Shao et al., 2024)\n\r\n\r\nThe Transformer Architecture\n\r\nTransformer offers innovative solutions like its ability to process tokens in parallel, in contrast to sequential processing constraints in Long Short-Term Memory (LSTM) and Recurrent Neural Networks (RNNs). The transformer architecture achieves parallel processing through its multi-head self-attention mechanism which is a crucial technique of transformers that model complex relationships between different token entities. \n\r\n\r\nThe transformer architecture is built around two main components: the encoder and the decoder. Encoder transforms input sequences into high-dimensional embeddings, while the decoder uses these embeddings to generate output sequences. A typical transformer model is composed of multiple stacked layers of both encoders and decoders as shown in Figure 2.5.\n\r\n\r\nUnlike traditional models that process inputs one step at a time, transformers operate on the entire input simultaneously, enabling much faster and more efficient parallel processing. However, since Transformers do not process data in order, they need a way to capture the sequence of the input. This is achieved through positional encoding, which assigns each token (like a word in a sentence) a unique position-based signal. This technique ensures the model understands the order of tokens. Without positional encoding, the Transformer would treat the sentence as a random collection of words, ignoring word order completely. (Shao et al., 2024)\n\r\n\r\nApplications and Use Cases of LLMs\n\r\nLLMs have the capability to understand natural language and perform tasks like sentiment analysis and question answering, as well as natural language generation tasks such as content creation and automated responses. Their effectiveness lies in their ability to understand and generate human-like texts. For instance, LLMs like GPT-3 are shown to have the capability to generate articles, reports and even artistic creations like poetries. (Ren, 2024)\n\r\n\r\nMoreover, LLMs are applied in coding, design, requirements gathering, code refactoring, documentation and analytics. For instance, LLM like GPT-4 from OpenAI is strongly capable in several software engineering tasks, including coding, comprehension, execution and reasoning. It demonstrates the ability to interpret results in natural language and generate code from descriptions. (Fu et al., 2023)\n\r\n\r\nChallenges of LLMs\n\r\nAlthough LLMs are effective in automating and accelerating text analytic tasks, it also comes with a set of challenges which include perpetuating biases, limitations in accuracy for specific evaluation purposes, and potential real-world harm, necessitating collaboration between the evaluation and data science communities to address these issues. (Head et al., 2023)\n\r\n\r\nOther than ethical implications and bias challenges, LLMs face the challenge of demand for substantial computational resources. As LLMs become increasingly powerful, it demands more computing power which can be costly and environmentally unsustainable. To illustrate, data centers that provide computational power and train LLMs models demand high energy consumption. The source of this electricity usually comes from non-renewable sources. To address this issue, the use of renewable energy sources should be promoted and research should be conducted to discover more efficient model architectures to reduce the amount of computation. (Ren, 2024)\n\r\n\r\nTable 2.2 Lists of Major LLMs on the Market\n\r\n\r\n2.6.3 Artificial Intelligence in Education (AI)\r\nArtificial Intelligence (AI) has emerged as a transformative technology across various fields and industries, with education being a significant area of influence. From tailoring learning experiences to automating administrative tasks, AI is helping to make education more efficient, engaging and effective. Its applications range from personalized learning that cater to individual needs, to tools that help educators manage grading and communication more easily. However, along with these benefits also come with its set challenges.\n\r\n	\n\r\n	Applications in Education\n\r\nAI can be applied and integrated into tutoring systems that provide students with immediate feedback and assistance. These systems are effective in simulating one-to-one tutoring, offering explanations, practice problems and guidance tailored to student&#039;s pacing and level for understanding. This application of AI in tutoring systems is particularly helpful for students who need extra help outside of regular class hours. (Bit et al., 2024)\n\r\n\r\nAI-driven predictive modelling can identify students at risk of academic failure by analyzing various data features such as attendance rate, grades, and failure rates. These early insights can help educators to perform early intervention and targeted support to assist students. For instance, the use of AI can help with identification of students at risk of dropping out. This is done by analyzing large amounts of data and factors that can affect academic performance. Machine learning algorithms can be used to detect patterns in large datasets and predict which students are likely to drop out. (Duarte et al., 2023)\n\r\n\r\n	Benefits of AI in Education\n\r\nUsing AI in Education offers various benefits that traditional education could not achieve. One of the notable benefits of applying AI in education include accessibility and inclusion. AI can enable education to be more accessible to students with disabilities. This is achieved through using technologies like speech recognition and text-to-speech to enhance learning experiences for various student populations. (Trivedi, 2023)\n\r\nAI promotes lifelong learning by providing personalized learning paths that adapt to each individual&#039;s pace, goals, and preferences. This allows individuals to continuously develop new skills and knowledge throughout different stages of life, making education more flexible and relevant in a fast-changing world. (Bajaj, 2022)\n\r\n	Challenges and Considerations\n\r\nThe use of AI in education raises ethical issues such as academic integrity issues. AI may be misused by students to complete assignments or solve problems in tests, which may lead to plagiarism and integrity issues. This behavior can result in students earning high grades for work they did not genuinely produce. (Choi et al., 2025)\n\r\n\r\nAdditionally, another challenge faced by having AI in education include bias and inequity. AI systems may unintentionally reinforce existing biases if it is trained on skewed or imbalance biased data. As a result, this can create poor learning experience and outcomes for students from diverse backgrounds. (Bit et al., 2024) \n\r\n2.7 Existing System\r\n2.7.1 QANDA\r\nQANDA, which stands for Question and Answer, is an educational app that assists students in quickly and efficiently solving academic questions using artificial intelligence (AI). It was initially launched as a mobile application that enables users to snap a photo of a problem.The type of problem could be a math or science question and the user is able to receive instant, step-by-step solutions. This functionality is powered by Optical Character Recognition (OCR) combined with AI that interpret the question and generate appropriate answers.\n\r\nSince its launch, QANDA has transformed from a simple homework assistance tool into a full-fledged AI tutoring platform. It now includes features such as an AI chatbot that offers explanations, breaks down complex topics, and mimics human tutoring in natural language. Another notable feature, “Cramify,” allows users to upload notes, which the system summarizes and converts into personalized study materials like sample questions and answers, aiding exam preparation.\n\r\nQANDA supports several languages and has gained significant traction among students in Asia. Its real-time academic support and personalized learning experience set it apart. By integrating OCR, natural language processing (NLP), and machine learning, QANDA effectively combines traditional learning methods with cutting-edge AI technology. (QANDA Team, n.d.)\n\r\n2.7.2 Quizlet\r\nQuizlet is a popular online learning platform that helps students study a wide range of subjects using digital flashcards and interactive tools. Users can create their own study sets or access millions of sets made by others, covering everything from languages to science and history. Its simple, user-friendly design and accessibility on both mobile devices and web browsers make it a go-to tool for students and teachers alike.\n\r\nA standout feature of Quizlet is its AI-powered flashcard and quiz generator, which automatically transforms study material into different games (“Match” and “Gravity”) and customizable practice tests that adjust based on a student’s progress. Quizlet has also introduced Q-Chat, an AI chatbot that acts as a study buddy. With Q-Chat, students can have real conversations about their material, ask questions, get explanations, and receive personalized feedback which helps make studying more interactive and engaging.\n\r\nThe platform also tracks user performance, showing stats such as accuracy, time spent studying, and areas that need improvement. These insights help students stay on track with their goals and prepare more effectively for exams. While Quizlet once offered a public API for developers, it has since been removed, which limits outside integration. Still, Quizlet remains a highly effective tool for both personal study and classroom use, blending traditional learning techniques with modern AI features. (Quizlet, n.d.)\n\r\n2.7.3 Gauth\r\nGauth (formerly Gauthmath) is an AI-powered education app built to help students solve math problems quickly and effectively. Using advanced photo-recognition technology, students can snap a picture of a handwritten or printed math question, and the app provides a detailed, step-by-step solution. It’s designed not just to give answers, but to explain how to get there, making it a useful tool for learning, not just finishing homework.\n\r\nAlthough Gauth started out focused on math, it has expanded to include subjects like physics and chemistry. It also features an AI chatbot that guides students through problems, helping them understand the process and reasoning behind each solution. However, Gauth doesn’t offer features like flashcard creation or quiz generation. Instead, its strength is in accurate, on-demand problem-solving, especially in STEM topics.\n\r\nWhen it comes to tracking progress, Gauth keeps a simple history of solved problems, allowing students to look back at what they’ve worked on. But it doesn’t offer in-depth performance tracking or analytics. This makes it more of a handy problem-solver than a full study management tool. In short, Gauth is ideal for students who need quick, clear help with tricky questions especially in math and science rather than those looking for interactive study features or long-term learning plans. (Gauth, n.d.)\n\r\n2.7.4 Thetawave AI\r\nThetawaveAI operates as a cloud-based artificial intelligence platform specifically designed for educational content processing, functioning primarily as an advanced note-taking and study aid system rather than a neurotechnology application. The platform leverages natural language processing and machine learning algorithms to automatically transcribe audio and video content from lectures, meetings, and educational materials, then transforms this raw content into structured, organized notes with proper formatting, tables, and hierarchical information architecture.\n\r\n\r\nWithin the competitive landscape of AI-powered educational tools, ThetawaveAI offers functionality comparable to established platforms in lecture capture and study aid generation, with its primary differentiation being theta wave-inspired branding rather than novel technological capabilities. The platform competes with numerous existing services providing similar AI-driven content processing and learning aid creation. (TheTawave AI – Best AI Note Taker for College Students, n.d.)\n\r\n&#160;\r\n\r\n\r\n2.8 Feasibility Studies\r\n2.8.1 Technical Feasibility\r\nStudyAid will be developed as a web application for assisting individuals in solving their academic problems and enhancing their learning experience. The programming language selected is Hypertext Preprocessor (PHP) as backend logic. Bootstrap framework, CSS and HTML will be used for developing the frontend part of the application. MySQL will be used to store user data, metadata, and various transactional data. The integrated development environment (IDE) chosen is Visual Studio Code, which is an open source and widely used IDE that provides a wide range of support for different programming languages. For optical character recognition (OCR) features, Tesseract OCR will be used. It is an open source OCR engine for recognizing text within images and has been maintained by Google. \n\r\n\r\nAll selected open source tools and technologies are prioritized as they are made publicly available, allowing anyone to view, use, modify and distribute freely under open source license.\n\r\n2.8.2 Operational Feasibility\r\nStudyAid aims to perform all functionalities effectively and ensure that it has gone through proper testing before deployment. The application user interface will be developed and designed for ease of use, and guidance material will be provided to support user adoption to the application. 	\n\r\n	\n\r\nWith proper testing and user support, StudyAid will be operationally feasible and deliver consistent service that meets users’ requirements effectively.\n\r\n2.8.3 Schedule Feasibility\r\nThe estimated duration for completion of StudyAid is within 7 months. To ensure completion of development is within timeline, the project is divided into modules and modules are assigned to each team member equally. The project&#039;s timeline has been clearly defined within the Gantt chart. The chart outlines each module&#039;s timeline, key milestones, task dependencies, and buffer periods for addressing potential delays.\n\r\n&#160;\r\n\r\n\r\n2.9 Chapter Summary and Evaluation\r\nThis chapter presents a comprehensive literature review that establishes the theoretical and technological foundation for the StudyAid system development. The review begins by examining Agile methodology and its frameworks, including Kanban, Scrum, and Extreme Programming (XP), highlighting their benefits for rapid delivery, adaptability, and enhanced collaboration in software development projects. The chapter then covers essential software engineering practices including requirement analysis techniques (viewpoint-oriented analysis, joint application design, and fact gathering), design strategies (object-oriented and functional-oriented design), and architectural patterns (Model-View-Controller, layered architecture, and client-server). A significant portion focuses on testing methodologies, specifically white-box and black-box testing techniques, which are crucial for ensuring system quality and reliability. The review extensively explores existing technologies relevant to StudyAid, particularly Optical Character Recognition (OCR) technology and its evolution from traditional template matching to advanced AI-driven methods using CNNs, RNNs, and Transformer architectures. The chapter also examines Large Language Models (LLMs), AI applications in education, and existing educational tools like Quizlet, Gauth, and Thetawave AI to understand the current landscape. Finally, it addresses feasibility studies covering technical, operational, and schedule considerations, providing a comprehensive assessment framework for the project&#039;s viability and successful implementation.\n\r\n 	\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChapter 3\n\r\n\r\nMethodology and Requirements Analysis\n\r\nMethodology and Requirements Analysis\n\r\n\r\nThis chapter describes how requirements are elicited and analyzed to clearly define and identify requirements in the system. This chapter includes requirement analysis, software development methodology, requirement elicitation technique, functional requirements and non-functional requirements.\n\r\n3.1 Software Development Methodology\r\nSoftware Development Methodology is a structured approach to each phase of software development life cycle including planning, managing, building, testing and deployment. \n\r\n3.1.1 Kanban (Agile Methodology)\r\n\r\nFigure 3.1 Example of Kanban Board\n\r\nKanban is an effective project management methodology that was originally developed for the manufacturing process and since has been adapted for various fields, including software development, marketing, and product management. It is designed to optimize workflow efficiently by visualizing tasks and limiting work in progress tasks. For the StudyAid project, Kanban is selected and applied as a preferred project management approach due to its visual nature and flexibility.\n\r\n\r\nKanban uses visual boards to represent tasks and their progress. These boards can be physical or digital, with columns representing different stages of workflow, such as “Backlog”, &quot;To Do&quot;, “In Progress”, “Review”, and &quot;Done&quot;, allowing teams to identify bottlenecks and streamline current operations. Kanban helps prevent bottlenecks by setting limits on the number of tasks in each stage. This encourages the team to focus on completing tasks before starting new ones.\n\r\n\r\n\r\n3.2 Requirement Gathering\r\n3.2.1 Stakeholder Analysis\r\nViewpoint-oriented Analysis\n\r\nViewpoint-oriented Analysis is a technique used in software engineering to capture and understand the diverse perspectives of different stakeholders involved in a project. The goal and focus of this technique is to ensure that the software system being developed meets the needs and expectations of all stakeholders. There are three categories of viewpoints which include: interactor viewpoints, indirect viewpoints and domain viewpoints. Interactor viewpoints include stakeholders who have direct interaction with the system. These stakeholders are usually end-users who use the system. Indirect viewpoints represent stakeholders who do not interact with the system directly but are affected by outcome or performance of the system. Lastly, domain viewpoints refer to specific domain or industry which the system operates. These viewpoints include standards, practices and constraints specific to the domain.\n\r\n\r\nTable 3.1 Viewpoint-oriented Analysis Table\n\r\n\r\n\r\nFigure 3.1 Viewpoint-oriented Analysis Hierarchy Chart\n\r\n3.2.2 Elicitation Technique\r\nKnowledge Reuse:\n\r\nKnowledge reuse is a systematic approach to leveraging existing knowledge assets from previous projects, organizational experience, and industry practices to inform current requirements gathering. It involves three phases: capture, identification, and validation. ThetaWave AI is selected as the system to be analyzed since it shares similar functionality with StudyAid.\n\r\n\r\nCapture\n\r\nThe capture phase collects and documents knowledge from completed projects, organizational repositories, and external sources. Key activities include document design rationales and trade-offs, and creating reusable requirement templates and patterns. Refer table A.1 in Appendix A to view the functional requirements captured.\n\r\nIdentification\n\r\nThe identification phase locates and selects relevant knowledge assets that apply to the current project context and requirements gathering needs. In this phase, it verifies that past project requirements fit current business environment, technology constraints, and stakeholder needs. Refer table A.2 in Appendix A to view the functional requirements identified.\n\r\nValidation\n\r\nThe validation phase evaluates, adapts, and confirms that identified knowledge assets are appropriate and applicable to the current project context. Refer A.3 in Appendix A to view functional requirements validated.\n\r\n&#160;\r\n\r\n\r\nObservation\n\r\nObservation is a powerful technique used to understand processes, behaviors, and interactions in real-world contexts. When conducted effectively, it can provide insights that may not be captured through interviews or questionnaires alone.\n\r\nThe following observation was conducted to examine how students manage their learning materials and facilitate study sessions. The observation of a study session began with the student gathering all necessary study materials, including lecture notes, slides, and other relevant resources. Being organized and having all materials at hand helps to focus and makes study sessions more efficient.\n\r\nAfter preparing the relevant materials, the student had set specific topics or concepts as achievable goals for the session. Clear goals provide direction and help measure progress throughout the study session. The student then skimmed through lecture notes and relevant textbook chapters to get an overview, followed by a detailed reading where he highlighted key points, formulas, and concepts. This review process reinforces learning and helps identify areas that require further clarification.\n\r\nMoreover, the student wrote summaries of key concepts in his own words, often in the form of notes, flashcards, and mind maps. These active learning techniques enhance understanding and retention of the material. After thoroughly reviewing and taking notes, the student began solving practice problems, such as past exam questions. He checked his answers against provided solutions and sought help for any problems that are difficult to solve, often preferring to get answers from large language models AI.\n\r\nThe student proceeded the session with a structured break schedule to relax, stretch, or have snacks, which helps maintain their focus and productivity during study sessions. Subsequently, the student used quizzes, practice tests to evaluate his comprehension. Identify areas where the student was still struggling and revisited those topics. The end of the study session was followed by reviewing material covered and summarizing key points learned, reviewing flashcards and storing his notes ensuring they are organized for future reference. \n\r\nThe observation of the student&#039;s study session provided valuable insights into effective study habits. The insights gained from this observation have highlighted user needs and enhanced the understanding of workflows. This technique enables software engineers to gather detailed user requirements. For instance, it was noted that users prefer organized and easily accessible study materials to ensure efficient study sessions.\n\r\n\r\n\r\n3.3 Requirements Overview\r\n3.3.1 System Structure Overview\r\n\r\nFigure 3.2 System Structure Chart\n\r\n3.3.2 Functional Requirements\r\n\r\nTable 3.5 Functional Requirements Table\n\r\n\r\n&#160;\r\n\r\n\r\n3.3.3 Non-functional Requirements\r\nUsability\n\r\nThe system shall prioritize usability to ensure that both students and educators can efficiently interact with its features. A clean, intuitive, and consistent user interface will be designed for use across desktops, tablets, and smartphones, ensuring accessibility and responsiveness (NFR_01). The goal is to achieve a System Usability Scale (SUS) score of 80 or above, indicating high user satisfaction. Additionally, first-time users must be able to complete basic actions, such as uploading documents or accessing AI-generated summaries, within five minutes without external guidance or training (NFR_02). This ensures that the platform is user-friendly and requires minimal onboarding effort.\n\r\nSecurity\n\r\nData security is critical, especially given the platform’s handling of personal academic content and credentials. All user data, including passwords, performance records, and uploaded documents, will be protected using AES-256 encryption and comply with the Malaysian Personal Data Protection Act (PDPA). User authentication will be strengthened with secure login practices and encrypt password ensuring resilience against brute-force attacks. These measures ensure that personal and academic information is well-protected, meeting legal and ethical standards.\n\r\nScalability\n\r\nThe system is designed to support future growth in both functionality and user base. It will follow a modular architecture that allows new academic or AI features to be added with less than 10% modification impact on existing modules. This approach reduces development overhead and risk during feature expansion. Moreover, the architecture shall support horizontal scaling, enabling the platform to handle up to 10,000 concurrent users without significant performance degradation. This ensures that the system remains stable and efficient as more users or institutional adopters come onboard.\n\r\nMaintainability\n\r\nMaintainability is essential for ensuring long-term sustainability and ease of upgrades. The source code will follow clean coding standards such as PEP8 (for Python) or equivalent language-specific conventions, with clear documentation and modular design. This enables any future developer to understand and modify any component of the system within 2 hours of review. In addition, the system will employ a version-controlled Continuous Integration/Continuous Deployment (CI/CD) pipeline to allow updates and bug fixes to be deployed with less than 5 minutes of downtime. This supports continuous improvement while minimizing disruption to users.\n\r\n3.3.4 Overall Use Case\r\n\r\nFigure 3.3 Overall Use Case Diagram\n\r\n&#160;\r\n\r\n\r\n3.3.5 Use Case Description\r\nUC01: Manage File\n\r\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\nUC02: Manage Learning Material\n\r\n\r\n&#160;\r\n\r\n\r\nUC03: Register\n\r\n\r\n\r\nUC06: Manage Folder\n\r\n\r\nUC07: Login\n\r\n&#160;\r\n\r\n\r\n3.4 Chapter Summary and Evaluation\r\nThis chapter outlines the methodology and comprehensive requirements analysis for the StudyAid system development. The chapter begins by establishing Kanban as the chosen Agile methodology for project management, utilizing visual boards with stages from &quot;Backlog&quot; to &quot;Done&quot; to optimize workflow and prevent bottlenecks. For requirement gathering, the team employed viewpoint-oriented analysis to capture diverse stakeholder perspectives, categorizing them into interactor viewpoints (users and software engineers), indirect viewpoints (educational institutions), and domain viewpoints (UI standards and AI service integration). The elicitation techniques included knowledge reuse, where ThetaWave AI was analyzed as a reference system through capture, identification, and validation phases, and direct observation of student study sessions to understand real-world learning behaviors and workflows. The chapter presents a detailed system structure with comprehensive functional requirements organized into three main modules: Content Management (document upload, folder and file management), Learning Material Management (summary, notes, and mind map generation), and User Management (registration and login). Additionally, it establishes critical non-functional requirements covering usability (SUS score of 80+, 5-minute learning curve), security (AES-256 encryption, PDPA compliance), scalability (support for 10,000 concurrent users, modular architecture), and maintainability (clean coding standards, CI/CD pipeline with minimal downtime), providing a solid foundation for successful system development and deployment.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChapter 4\n\r\n\r\nSystem Design\n\r\nSystem Design\n\r\n\r\nThis chapter describes how the StudyAid learning management system will be designed, starting from the architecture aspects, user interface, data design and process design.\n\r\n4.1 Software Architecture\r\n4.1.1 Client-Server Architecture with MVC\r\n\r\nFigure 4.1 Client-Server Architecture with MVC\n\r\n\r\nThe StudyAid learning management system employs a Client-Server Architecture integrated with the Model-View-Controller (MVC) pattern to ensure a well-structured, maintainable, and scalable application. The client side consists of a web browser that provides the interface for users to interact with the system. It sends requests to the server, which processes these requests, executes business logic, manages data, and returns appropriate responses for rendering in the browser.\n\r\nThe MVC pattern on the server organizes the system into three main components. The Model layer is responsible for managing application data, rules, and business logic. In StudyAid, this includes components such as the AuthModel, LmModel, and UserModel. These models interact with the database to handle storage, retrieval, and updates. The View layer forms the presentation component, including AuthView, LearningView, DashboardView, and ProfileView, which define how information is presented to the user. The Controller layer, represented by AuthController, UserController, and LmController, manages the flow of data between the Model and the View. It processes user requests from the client, updates the appropriate Models, and selects Views to display the results.\n\r\nThe integration of Client-Server and MVC architectures ensures that responsibilities are clearly separated. The client focuses solely on displaying information and capturing user input, while the server handles all business logic and data management. This separation improves system maintainability, as changes in one layer do not directly affect others. It also enhances scalability, since additional features or components can be introduced without disrupting the entire system.\n\r\nFurthermore, the architecture provides security by centralizing logic and validation on the server, reducing risks from client-side manipulation. Performance is optimized as requests are processed centrally and data interactions are efficiently managed through the database. Overall, this architecture supports reliability, flexibility, and long-term extensibility of the StudyAid learning management system.\n\r\n4.2 UI Design\r\n\r\nFigure 4. UI Design Layout for Uploading Document Page\n\r\n&#160;\r\n\r\n\r\n\r\nFigure 4. UI Design Layout for Document List Page\n\r\n\r\n\r\nFigure 4. UI Design Layout for Summary Page\n\r\n\r\nFigure 4. UI Design Layout for Note Page\n\r\n\r\n\r\nFigure 4. UI Design Layout for Mindmap Page\n\r\n&#160;\r\n\r\n\r\n4.3 Data Design\r\n4.3.1 Entity Relationship Diagram (ERD)\r\n\r\n\r\nFigure 4.2 Entity Relationship Diagram\n\r\n&#160;\r\n\r\n\r\n4.3.2 Data Directory Table\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n4.4 Process Design\r\n4.4.1 Activity Diagram\r\n\r\n\r\n\r\n&#160;\r\nFigure 4. Manage File Activity Diagram\n\r\n\r\n\r\n\r\n\r\n\r\nFigure 4. Manage Folder Activity Diagram\n\r\n&#160;\r\n\r\n\r\n\r\n\r\n\r\nFigure 4. Manage Learning Material Activity Diagram\n\r\n&#160;\r\n\r\n\r\n\r\n\r\n\r\nFigure 4. Register Activity Diagram\n\r\n\r\nFigure 4. Login Activity Diagram\n\r\n\r\n&#160;\r\n\r\n\r\n4.4.2 Sequence Diagram\r\nUser Selects File to Generate Learning Material\n\r\n\r\n\r\n&#160;\r\n\r\n\r\nReference: Generate Summary\n\r\n\r\nFigure 4. Sequence Diagram\n\r\n\r\n&#160;\r\n\r\n\r\nRef: Generate Note\n\r\n\r\n\r\nRef: Generate Mindmap\n\r\n\r\n\r\n\r\n\r\nRef: Export\n\r\n\r\n\r\nManage File\n\r\n\r\n\r\n&#160;\r\n\r\nRef: Upload Document\n\r\n\r\n\r\nRef: Remove File\n\r\n\r\n\r\nRef: Rename File\n\r\n\r\n\r\n&#160;\r\n\r\n\r\nRef: Search File\n\r\n\r\n\r\nRef: Assign file to folder\n\r\n\r\n\r\nRegisters an Account\n\r\n\r\n&#160;\r\n\r\n\r\nLogin Account\n\r\n\r\n&#160;\r\n\r\n\r\nManage Folder\n\r\n\r\n&#160;\r\n\r\n\r\nRef: Create Folder\n\r\n\r\nRef: Remove folder\n\r\n\r\n\r\n&#160;\r\n\r\n\r\nRef: Rename Folder\n\r\n\r\n\r\nRef: Search Folder\n\r\n\r\n&#160;\r\n\r\n\r\nRef: Remove file from folder\n\r\n\r\n&#160;\r\n\r\n\r\n4.5 Detail Design\r\n4.5.1 Class Diagram\r\n\r\n4.5.2 Component Diagram\r\n\r\nFigure 4. Component Diagram\n\r\n&#160;\r\n\r\n\r\n4.5.3 Deployment Diagram\r\n\r\nFigure 4. Deployment Diagram\n\r\n\r\n\r\n4.6 Algorithm Design\r\nThe algorithm design phase outlines the logical procedures and computational steps required for the system to perform its intended functions. Each algorithm is designed to address specific system requirements, ensuring that processes such as data handling, user interaction, and automation are efficient, scalable, and maintainable.\n\r\nThis section details the algorithms that govern core functionalities of the StudyAid Learning Management System (LMS), with a particular focus on the integration of artificial intelligence components. Among these, the Large Language Model (LLM) plays a central role in supporting content processing, content generation, and interaction between the user and the system.\n\r\n&#160;\r\n\r\n\r\n4.6.1 Large Language Model (LLM)\r\n\r\nFigure 4. LLM Algorithm Pseudocode\n\r\n&#160;\r\n\r\n\r\nThe pseudocode outlined in this figure formalizes the algorithm workflow of the learning management system and integrates a Large Language Model (LLM) to enhance and enable dynamic user interactions. The process begins when the Controller receives a user request and extracts its type and content for further processing. Preprocessing ensures that uploaded materials are cleaned, tokenized, and formatted into structured data suitable for contextual use. The system then maps the request type to a specific LLM task such as summarization, quiz generation, chatbot query handling, mindmap construction, or notes generation and generates a tailored prompt accordingly. The request is forwarded to the external LLM service through an API call, after which the raw output undergoes postprocessing to refine its structure, enforce task-specific constraints, and ensure clarity. The Model component is then responsible for storing the refined output in the database, linking it to the relevant user and request metadata. Finally, the View presents the processed and formatted response back to the end user. This integration of algorithmic steps with the MVC framework ensures a modular, maintainable, and extensible approach to embedding LLM-driven functionalities within the system’s architecture.\n\r\n&#160;\r\n\r\n\r\n4.7 Chapter Summary and Evaluation\r\nThis chapter presents a comprehensive system design for the StudyAid learning management system, establishing the technical foundation through multiple design perspectives. The chapter begins with the software architecture, implementing a Client-Server Architecture integrated with the Model-View-Controller (MVC) pattern to ensure clear separation of responsibilities, maintainability, and scalability. The client-side web browser handles user interface interactions, while the server manages business logic through organized components including AuthModel, LmModel, UserModel, and their corresponding controllers and views. The UI design section showcases intuitive interface layouts for key functionalities including document upload, file management, and AI-generated content display pages for summaries, notes, and mind maps. The data design presents a detailed Entity Relationship Diagram and comprehensive data dictionary covering 14 interconnected tables ranging from basic user management (User, Session) to complex learning analytics (PerformanceReport, FlashcardSession), ensuring robust data organization and relationships. Process design illustrates system workflows through activity diagrams for file management, folder operations, learning material generation, and user authentication, complemented by sequence diagrams that detail component interactions during key operations. The chapter concludes with algorithm design, particularly focusing on the Large Language Model (LLM) integration algorithm that coordinates preprocessing, prompt generation, API communication, postprocessing, and data storage within the MVC framework to deliver AI-powered educational features efficiently and maintainably.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChapter 5\n\r\n\r\nImplementation and Testing\n\r\nImplementation and Testing\n\r\n\r\nA short introduction that describes what will be included in this chapter.\n\r\nIMPORTANT NOTE TO STUDENTS: Include details about:\n\r\n\r\nImplementation\n\r\n\r\nA detailed description of how you actually carried out the implementation (e.g., coding, etc.) of your system/prototype. \n\r\nInclude code snippets and descriptions to show how the requirements of the application/prototype have been met – \n\r\n\r\nFor Smart Campus projects, c\n\r\node snippets of the MQTT protocol for both client side and server side has to be included with explanation\n\r\n.\n\r\n\r\nInclude descriptions of important settings - \n\r\nSetting for server, network protocol, IP, database, security\n\r\n\r\nNote: this should \n\r\nnot\n\r\n be a chronological account of the work you carried out. \n\r\n\r\n\r\nTesting\n\r\n\r\nAll test cases that have been carried out must be provided - To tabulate the test cases in tables\n\r\n\r\nNote: Students may also opt to split Implementation and Testing into 2 separate chapters.\n\r\nSub-section 1 Heading\n\r\n\r\nSub-sections should be used to divide the chapter into logical parts. \n\r\nSub-subsection Heading\n\r\n\r\nSub-section numbering should be limited to a maximum of 3 levels (e.g. 5.3.1) in order to avoid confusion.\n\r\nSub-section 2 Heading\n\r\n\r\nSub-section 1 Heading\n\r\n\r\nSub-sections should be used to divide the chapter into logical parts. \n\r\nSub-subsection Heading\n\r\n\r\nSub-section numbering should be limited to a maximum of 3 levels (e.g. 5.3.1) in order to avoid confusion.\n\r\n\r\nSub-section 1 Heading\n\r\n\r\nSub-sections should be used to divide the chapter into logical parts. \n\r\nSub-subsection Heading\n\r\n\r\nSub-section numbering should be limited to a maximum of 3 levels (e.g. 5.3.1) in order to avoid confusion.\n\r\n\r\nChapter Summary and Evaluation\n\r\n\r\nAt the end of each chapter, evaluate the contents stated or discussed in the relevant sub-sections. \n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChapter 6 (if applicable)\n\r\n\r\nSystem Deployment\n\r\nSystem Deployment\n\r\n\r\nThis chapter would be applicable for students who have embarked on a real-life industrial project.  Students in this case would need to describe how the deployment has been carried out.  Some of implementation tasks which need to be described include: training, file conversion or creation, and changeovers.\n\r\nSystem Backup and Risk Management\n\r\n\r\nDescribe the procedures to backup the existing system for changeover purpose. Discuss the potential risk(s) for the changeovers and the solution.\n\r\nOn-site Setup\n\r\n\r\nDescribe the preparations to be done prior to the setup of the new system on client’s site. Discuss the procedures to setup the new system, schedule, etc.\n\r\nTraining Procedure\n\r\n\r\nDescribe the procedures on the training procedures, contents, schedule, etc.\n\r\nFollow-up \n\r\n\r\nDescribe the plan or procedures to follow up with the client (company) to verify the system reliability.\n\r\nChapter Summary and Evaluation\n\r\n\r\nAt the end of each chapter, evaluate the contents stated or discussed in the relevant sub-sections. For example,\n\r\nProblems faced.  Describe the various problems faced by students in the course of doing the project.\n\r\n\r\nSolutions.  What have been done to solve the problems?\n\r\n\r\nWhat tools and techniques have been used and reasons for using them.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChapter 7\n\r\n\r\nDiscussions and Conclusion\n\r\nDiscussions and Conclusion\n\r\n\r\nEach student is required to make an evaluation of the project he/she has embarked on.  The project evaluation may include the following sections.\n\r\nIMPORTANT NOTE TO STUDENTS: In this chapter, for problems related to code, hardware, internet connection, etc (where applicable):\n\r\nList the technical problems faced and state how they were resolved\n\r\n\r\nList the unsolved technical problems for future enhancement\n\r\n\r\nList the achieved objectives/modules\n\r\n\r\nList the incomplete parts for future enhancement - this is regardless the parts listed in the pre-determined scope. Suggestions for future improvement\n\r\n\r\nSummary\n\r\n\r\nSummarize the project including the problem and proposed solutions, justification of the choice of tools, techniques and methodologies used in this project.\n\r\nAchievements\n\r\n\r\nStudents are required to evaluate the project’s achievement against project objectives, completion of the project, students’ view of the strengths and weaknesses of the work done.  \n\r\nContributions\n\r\n\r\nDiscuss the creativity, innovativeness, contribution of the proposed system. Explain why the proposed system is necessary. Describe the marketability of the system.\n\r\nLimitations and Future Improvements\n\r\n\r\nIdentify the limitations of the research or project. Provide suggestions for improvement or further development of the system or research in the future.\n\r\nIssues and Solutions\n\r\n\r\nStudents are required to describe the various problems faced by students during the project development and explain what has been done to solve the problems.  The valuable experiences gained or lessons learnt through the project as a whole. The issues may include technical issues, project management issues, team dynamics problems, and other difficulties encountered and lessons learnt. How the issues are solved or can be solved to ensure the project can be completed on time or to be improved in the future.\n\r\nReferences\r\nAbrahamsson, P., Salo, O., Ronkainen, J., &amp; Warsta, J. (2017, September 25). Agile software development Methods: review and analysis. arXiv.org. https://arxiv.org/abs/1709.08439\n\r\nAshtari, H. (2022, September 29). Agile Software Life Cycle, Methodology, Examples - Spiceworks Inc. Spiceworks Inc. https://www.spiceworks.com/tech/devops/articles/what-is-agile-software-development\n\r\nAraújo, J., &amp; Coutinho, P. J. G. (2003). Identifying Aspectual Use Cases Using a Viewpoint-Oriented Requirements Method.\n\r\nAhmad, S., Hashim, Z., &amp; Asmai, S. A. (2020). A Study on Reuse-based Requirements Engineering by Utilizing Knowledge Pattern. International Journal on Advanced Science, Engineering and Information Technology, 10(1), 41–46. https://doi.org/10.18517/IJASEIT.10.1.10168\n\r\nBolanle, O. F., &amp; Isaac, A. O. (2014). Software Reuse Facilitated by the Underlying Requirement Specification Document: A Knowledge-Based Approach. 3(3), 21. https://doi.org/10.11648/J.AJSEA.20140303.11\n\r\nBaillifard, A., Gabella, M., Lavenex, P. B., &amp; Martarelli, C. S. (2023, September 10). Implementing Learning Principles with a Personal AI Tutor: A Case Study. arXiv.org. https://arxiv.org/abs/2309.13060\n\r\nBajaj, R. (2022). Exploring the Scope of Artificial Intelligence Across Various Domains with a Focus on Its Impact on Education. https://doi.org/10.53555/sfs.v8i3.2440\n\r\nBit, D., Biswas, S., &amp; Nag, M. (2024). The Impact of Artificial Intelligence in Educational System. International Journal of Scientific Research in Science and Technology, 11(4), 419–427. https://doi.org/10.32628/ijsrst2411424\n\r\nChatel, S., &amp; Détienne, F. (2007, March 2). Strategies in object-oriented design. arXiv.org. https://arxiv.org/abs/cs/0703008\n\r\nChang, C., Cleland-Huang, J., Hua, N. S., &amp; Kuntzmann-Combelles, A. (2001). Function-class decomposition: a hybrid software engineering method. Computer, 34(12), 87–93. https://doi.org/10.1109/2.970582\n\r\nChoi, W. C., Choi, I. C., &amp; Chang, C. (2025). The Impact of Artificial Intelligence on Education: The Applications, Advantages, Challenges and Researchers’ Perspective. https://doi.org/10.20944/preprints202501.1420.v1\n\r\nCubet. (n.d.). Exploring the architecture pattern of MVC. Cubet. \n\r\nhttps://www.cubettech.com/resources/blog/exploring-the-architecture-pattern-of-mvc\n\r\nCimen, C., Kavurucu, Y., &amp; Aydin, H. (2014, April 1). Usage of Thin-Client/Server architecture in computer aided education. Learning &amp; Technology Library (LearnTechLib). https://www.learntechlib.org/p/153686/\n\r\nChahal, J. K., Bhandari, A., &amp; Behal, S. (2019). Distributed denial of service attacks: a threat or challenge. New Review of Information Networking, 24(1), 31–103. https://doi.org/10.1080/13614576.2019.1611468\n\r\nCrudu, A. (2025, June 13). How integration testing Boosts software quality - Insights for quality Analysts. MoldStud - Custom Software Development Company. https://moldstud.com/articles/p-how-integration-testing-boosts-software-quality-insights-for-quality-analysts\n\r\nDada, O. A. (n.d.). The adoption of Software Engineering practices in a Scrum environment | African Journal of Science, Technology, Innovation and Development. African Journal of Science, Technology, Innovation and Development. https://journals.co.za/doi/full/10.1080/20421338.2021.1955431\n\r\nDecision table in software testing |Professionalqa.com. (n.d.). https://www.professionalqa.com/decision-table-in-software-testing\n\r\nDuarte, N., Montoya Pérez, Y., Beltran, A. J., &amp; Bolaño García, M. (2023). Use of Artificial Intelligence in Education: A Systematic Review. https://doi.org/10.46254/sa04.20230169\n\r\nExtreme Programming (XP): revolutionizing software development. (2023, May 3). https://www.theagilehandbook.com/blog/extreme-programming\n\r\nExtreme programming misconceptions. (n.d.). https://www.meegle.com/en_us/topics/extreme-programming/extreme-programming-misconceptions\n\r\nEllims, M., Bridges, J., &amp; Ince, D. C. (2004, December). Unit testing in practice. ResearchGate. Retrieved July 3, 2025, from https://www.researchgate.net/publication/4118109_Unit_testing_in_practice\n\r\nFu, Y., Zhang, Y., Yu, Z., Li, S., Ye, Z., Li, C., Wan, C., &amp; Lin, Y. C. (2023, September 19). GPT4AIGCHIP: Towards Next-Generation AI Accelerator Design Automation via Large Language Models. arXiv.org. https://arxiv.org/abs/2309.10730\n\r\nGauth. (n.d.). Gauth - best AI Homework Helper for all school subjects. https://www.gauthmath.com/\n\r\nHead, C. B., Jasper, P., McConnachie, M., Raftree, L., &amp; Higdon, G. (2023). Large language model applications for evaluation: Opportunities and ethical implications. New Directions for Evaluation, 2023, 33–46. https://doi.org/10.1002/ev.20556\n\r\nJain, J., &amp; Gupta, M. (2024). AI-Driven Machine Learning-Enhanced OCR: Transformative Innovations in Real-Time Text Recognition for Automation and Accessibility. https://doi.org/10.21428/e90189c8.0d085420\n\r\nKim, M., &amp; Yun, S. (2018). Understanding the barriers to students&#039; self-study and developing effective strategies. \n\r\nJournal of Educational Research and Practice, 8(1), 56-64. https://doi.org/10.4236/jedr.2018.81005\n\r\nLee, S.-H., &amp; Yoo, H. (2013). Requirement Analysis for Aspect-Oriented System \n\r\nDevelopment (pp. 1201–1209). Springer, Dordrecht. https://doi.org/10.1007/978-94-007-5860-5_144\n\r\nMishra, A., Sikdar, J., &amp; Kumar, S. (2024). Deep Learning-Based Optical Character Recognition for Robust Real-World Conditions: A Comparative Analysis. 1–7. https://doi.org/10.1109/icccnt61001.2024.10726007\n\r\nSuresh, R. S., Naik, N., &amp; Shah, N. (2022).\n\r\nA systematic review on personalized feedback in digital learning environments. Discover Education, 2(1), 1–19. \n\r\nhttps://doi.org/10.1016/j.digedu.2022.100052\n\r\nSrivastava, P. R., Patel, P., &amp; Chatrola, S. (2009). Cause effect graph to decision table generation. ACM SIGSOFT Software Engineering Notes, 34(2), 1–4. https://doi.org/10.1145/1507195.1507216\n\r\nSilveira, M. C., &amp; Vidal, R. M. (2002). Software Reuse with Use Case Patterns (pp. 96–100). Springer, Berlin, Heidelberg. https://doi.org/10.1007/3-540-46105-1_12\n\r\nTeresa, S., E. (2018). Object-Oriented Design. EBSCO. Retrieved July 1, 2025, from https://www.ebsco.com/research-starters/computer-science/object-oriented-design\n\r\nTu, Z. (2023). Research on the application of layered architecture in computer software development. Journal of Computing and Electronic Information Management, 11(3), 34–38. https://doi.org/10.54097/jceim.v11i3.08\n\r\nTrivedi, N. B. (2023). AI in Education-A Transformative Force. 1, 1–4. https://doi.org/10.1109/idicaiei58380.2023.10406541\n\r\nQANDA Team. (n.d.). https://mathpresso.com/en\n\r\nQuizlet. (n.d.). About Quizlet | Quizlet. https://quizlet.com/mission\n\r\nRen, M. (2024). Advancements and Applications of Large Language Models in Natural Language Processing: A Comprehensive Review. Applied and Computational Engineering, 97(1), 55–63. https://doi.org/10.54254/2755-2721/97/20241406\n\r\nRoediger, H. L., &amp; Butler, A. C. (2011). \n\r\nThe critical role of retrieval practice in long-term retention. Trends in Cognitive Sciences, 15(1), 20-27. \n\r\nhttps://doi.org/10.1016/j.tics.2010.09.003\n\r\nRana, M. E., &amp; Saleh, O. S. (2022). High assurance software architecture and design. In Elsevier eBooks (pp. 271–285). https://doi.org/10.1016/b978-0-323-90240-3.00015-1\n\r\nPanadero, E., Andrade, H., &amp; Brookhart, S. (2023). \n\r\nStudents’ perceptions of self-assessment: A systematic review of 44 studies. Educational Psychology Review, 35, 1–26. \n\r\nhttps://doi.org/10.1007/s10648-023-09799-1\n\r\nYan, Z., &amp; Brown, G. T. L. (2022). \n\r\nEffects of self-assessment and peer-assessment interventions on students’ academic performance: A meta-analysis of randomized controlled trials. Educational Research Review, 36, 100457.\n\r\nhttps://doi.org/10.1016/j.edurev.2022.100457\n\r\nM, A. (2010). Requirements Analysis through Viewpoints Oriented Requirements Model (VORD). International Journal of Advanced Computer Science and Applications, 1(5). https://doi.org/10.14569/ijacsa.2010.010502\n\r\nModi, M., Shah, A., Kothadiya, D., &amp; Rahevar, M. (2024). Optical Character Recognition: Comparative Analysis of Tesseract and Textract on Diverse Datasets. 913–919. https://doi.org/10.1109/icacrs62842.2024.10841500\n\r\nAwati, R. (2023, June 14). joint application development (JAD). Search Software Quality. https://www.techtarget.com/searchsoftwarequality/definition/JAD\n\r\nN Nayab. (2011, July 24). Basics of JAD Methodology. BrightHubPM	https://www.brighthubpm.com/methods-strategies/121907-how-to-involve-the-customer-and-other-stakeholders-in-project-design-and-execution\n\r\nPu, Y., &amp; Liu, Q. (2009). A Viewpoint-Oriented Requirements Elicitation Integrated with Aspects. Computer Science and Information Engineering, 7, 706–711. https://doi.org/10.1109/CSIE.2009.604\n\r\nSalim, A., &amp; Rusdiansyah, R. (2025). Implementasi Black Box Testing pada website E-commerce Shopee menggunakan State Transition Testing. Jurnal Informatika Dan Bisnis, 13(2), 161–170. https://doi.org/10.46806/jib.v13i2.1321\n\r\nShao, M., Basit, A., Karri, R., &amp; Shafique, M. (2024). Survey of different Large Language Model Architectures: Trends, Benchmarks, and Challenges. IEEE Access, 1. https://doi.org/10.1109/access.2024.3482107\n\r\nSingh, A., Jangra, S., &amp; Aggarwal, G. (2024). EnvisionText: Enhancing Text Recognition Accuracy through OCR Extraction and NLP-based Correction. 47–52. https://doi.org/10.1109/confluence60223.2024.10463478\n\r\nStaff, R. (2024, July 14). What is Requirements Gathering? Requirements.com. https://requirements.com/Content/Announcements/what-is-requirements-gathering\n\r\nSuppiah, Y., Duriat, N., &amp; Widyarto, S. (2016). Agile Methodology Adoption in Software Development: A Literature review. https://ojs.journals.unisel.edu.my/index.php/icf/article/view/12\n\r\nS, B. (2025, April 2). What is Scrum methodology? An introduction for agile teams. NimbleWork. https://www.nimblework.com/agile/scrum-methodology/\n\r\nJama Software. (2024, December 13). Requirements gathering techniques for agile product teams. https://www.jamasoftware.com/requirements-management-guide/requirements-gathering-and-management-processes/11-requirements-gathering-techniques-for-agile-product-teams/\n\r\nOclarit, J. R., Compoc, J. V., Ancog, D. J., &amp; Tejada, R. V. D. (2024). SMARTPAWS: An Internet of Things (IoT) Pet feeder for dogs and cats using Arduino Uno. ResearchGate. https://doi.org/10.13140/RG.2.2.27220.00643\n\r\nGeeksforGeeks. (2024, May 15). Kanban Agile Methodology. GeeksforGeeks. https://www.geeksforgeeks.org/software-engineering/kanban-agile-methodology/\n\r\nGeeksforGeeks. (2025, March 24). System Testing Software Engineering. GeeksforGeeks. https://www.geeksforgeeks.org/system-testing/\n\r\n&#160;\r\nGuynes, C. S., &amp; Windsor, J. (2011). Revisiting Client/Server computing. Journal of Business &amp; Economics Research (JBER), 9(1). https://doi.org/10.19030/jber.v9i1.935\n\r\n\r\nGrinkov, V., Grinkova, G., &amp; Grinkov, S. (2024). Analysis of modern optical character recognition tools for character recognition and text from the image. Sistemi ì Tehnologìï Zv’âzku, Ìnformatizacìï Ta Kìberbezpeki, 1(6), 75–84. https://doi.org/10.58254/viti.6.2024.05.75\n\r\nVan Bolhuis, W. M., Bernsteiner, R., Hall, M., &amp; Fruhling, A. (2022). Enhancing IoT Project Success through Agile Best Practices. ACM Transactions on Internet of Things, 4(1), 1–31. https://doi.org/10.1145/3568170\n\r\nValente, M. T. (n.d.). Chapter 7: Architecture – Software Engineering: A Modern Approach. https://softengbook.org/chapter7\n\r\nWickramasinghe, S. (2022, May 13). Ultimate Guide to the Advantages and Disadvantages of software testing. AccelaTest. https://accelatest.com/advantages-and-disadvantages-of-software-testing\n\r\nWang, Z. (2007). Viewpoint Expression Model Based on Problem Frame. Computer Engineering. https://en.cnki.com.cn/Article_en/CJFDTotal-JSJC200715025.htm\n\r\nTheTawave AI – Best AI Note Taker for College Students. (n.d.). \n\r\nhttps://thetawave.ai/\n\r\n\r\n\r\n\r\n\r\nAppendices\n\r\nIn order to enhance better understanding of the project, students should as far as possible include all directly relevant materials, figures or diagrams in the main body rather than in the Appendix.  The appendix is reserved only for items which may not directly be relevant or essential to enhance a reader’s understanding of the project, or which may interrupt the smooth reading of the project document (for example being too voluminous).  \n\r\nAppendices should only include supportive materials directly referred to in the writing and should be kept to a minimum, e.g. selected pages of an annual report, not the entire document.  Examples of items included in Appendices are: \n\r\nCompany’s report and documentation, such as sample invoice, purchase order form, etc.\n\r\n\r\nProject meeting documentation e.g. minutes of meetings, tracking documents, memos etc.\n\r\n\r\nQuestionnaires and results, interview questions and results, pilot test and results, observation sheet and results, experiment test plan and results, etc.\n\r\n\r\nAnalysis/design diagrams (only those not incorporated in the main body of the report). \n\r\n\r\n\r\nIf there is more than one appendix, they should be identified as A, B, etc (e.g. Appendix A). Formulae and equations in appendices should be given separate numbering: Eq. (A.1), Eq. (A.2), etc.; in a subsequent appendix, Eq. (B.1) and so on. Similarly for tables and figures: Table A.1; Fig. A.1, etc.\n\r\nAppendix A\r\n	Table A.1 Knowledge Reuse - Capture\n\r\n\r\n	\n\r\nTable A.2 Knowledge Reuse - Identification\n\r\n\r\n	\n\r\nTable A.3 Knowledge Reuse - Validation\n\r\n\r\n\r\nIMPORTANT NOTE TO STUDENTS\n\r\n\r\nAPPENDIX n User Guide \n\r\nList the username and password of multiple roles (if applicable)\n\r\n\r\nProvide clear screen shots of each page, explain the functions of each button\n\r\n\r\n\r\nAs a rough guide, the user guide should include the following sections:\n\r\n\r\n\r\n\r\n\r\nSystem Document\n\r\nIn this section, students should provide the following pieces of information:\n\r\nSystem (hardware and software requirements)\n\r\n.  Students should describe the minimum hardware and software requirements to install the software application which has been developed by the students, for example, DBMS, OS, program development tools etc.\n\r\n\r\nInstallation\n\r\n.  Under this section, students should create an ‘installation’ CD and provide a brief step-by-step guide on how a new user can install the software on a computer system. Students should indicate any special setup information, such as the specific location of placing the database files, the SQL statements to add tables, etc.  Software source code should also be included in this CD.  Students are not required to print out the software code.\n\r\n\r\nOperation Document\n\r\nUnder this section, students are required to provide a brief step-by-step guide on how to use the installed software.  The guides should teach the user how to run the software and use its major functions and features.  For example, steps show guide the users on how to run the system, e.g. to use an executable file or to use the IDE. The login information such as username and password for each of the different users (or roles) must be provided. Some screen interfaces would be useful.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAPPENDIX n+1 Developer Guide*\n\r\n*To be included for Smart Campus Projects and Real-Life Projects. This section should include the following:\n\r\nList the necessary software, installer, API, library that must be installed\n\r\n\r\nList the authentication details, such as username and password for all security\n\r\n\r\n\r\nOther Appendices:\n\r\nSupporting documents\n\r\n\r\nNon-disclosure agreement (if applicable)\n\r\n\r\nOther detailed documentation, such as important references, interview results, survey results, etc.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&#160;\r\n\r\n\r\n\r\nThis page is intentionally left blank to indicate the back cover. Ensure that the back cover is black in color.', 'user_upload/1/content/Hello2/c71dd7c7-f37f-4be8-afa1-11c7bb055226.docx', '2025-10-25');
INSERT INTO `file` (`fileID`, `userID`, `folderID`, `name`, `fileType`, `fileSize`, `extracted_text`, `filePath`, `uploadDate`) VALUES
(2, 1, NULL, '2409322', 'docx', '', 'PHPWord\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nTUNKU ABDUL RAHMAN UNIVERSITY OF MANAGEMENT AND TECHNOLOGY \n\r\nACADEMIC \n\r\n\r\n\r\n\r\nEFFECTIVE \n\r\nDATE: \n\r\n\r\n\r\n16-MAY-2023\n\r\n\r\n\r\n\r\n\r\nREVISION \n\r\nDATE: \n\r\n\r\n\r\n-\n\r\n\r\n\r\n\r\n\r\nGUIDELINES\n\r\n\r\n\r\nREF. NO.: \n\r\n\r\n\r\nPO/104:23(R0)\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nTOTAL PAGE: \n\r\n\r\n\r\n4\n\r\n\r\n\r\n\r\n\r\n\r\nGeneral Guidelines for Use of Generative Artificial Intelligent (AI) tools in Teaching, Learning and Assessment (TLA) \n\r\n1. Lecturers are to remain positive about generative AI tools and their educational  potential. \n\r\n2. Do NOT limit any students’ access to generative AI tools or any form of technology  that could be beneficial to their learning experience. \n\r\n3. Generative AI tools may be used to generate preliminary ideas, refining writing  skills and enhance comprehension or writing techniques of any subject matter  within the context of the given academic tasks. \n\r\n4. Lecturers shall educate and support students to use the generative AI tools  ethically and responsibly.  \n\r\n5. Coursework assessments that allow excessive use of Generative AI tools shall be avoided. \n\r\n6. Lecturers shall intensify efforts by focusing more on experiential learning and  encourage students to demonstrate their learning by means of interpreting, live  demonstration, analysing, peer discussions, synthesising the relevant information and other interactive methods which develop students’ critical thinking and  problem-solving skills. \n\r\n7. Lecturers shall redesign the assessment criteria that required more oral  assessment, critical thinking and problem-solving skills, open-ended questions,  real case study or set milestones for the research project and provide feedback for  each milestone to understand students’ progress and prevent them from using  Generative AI excessively.  \n\r\n8. All staff and students shall strive to uphold the academic integrity and adhere  strictly to the University’s plagiarism policy which is made available on the intranet. \n\r\n9. The university takes plagiarism and other breaches of academic integrity including  violation of intellectual property and copyright laws, deceptive fabrication and all  other forms of cheating seriously. \n\r\n1 \n\r\n10.All academic works submitted for assessment purposes must be original and  students must not submit any academic work that merely presents ideas or  arguments solely derived from any generative AI tools or other sources without  proper acknowledgment. \n\r\n11.Students are required to acknowledge the originality of their works and use of  generative AI tools by signing a plagiarism statement form as attached. \n\r\n12.Any suspected plagiarism and use of generative AI tools without acknowledgement  during the grading of assessments will be treated as an academic misconduct and is subject to disciplinary action by the University.\n\r\n2 \n\r\nAttachment \n\r\nPlagiarism Statement Form \n\r\nI, Name _____YEOH MAN TIK____________Student ID_____24WMR09322___________  Programme ___RSW______Tutorial Group _________RSW2G4____confirm that the submitted  work are all my own work and is in my own words. \n\r\nI (Student Name) acknowledge the use of AI generative technology. \n\r\nSignature : _______yeoh_________ \n\r\nDate : __________3/5/2025______\n\r\n3 \n\r\n\r\n\r\n4', 'user_upload/1/content/c991d3c8-dbe5-4776-9f3f-1072d75a44f8.docx', '2025-10-27'),
(3, 1, NULL, 'Signature.jpg', 'jpg', '', '', 'user_upload/1/content/2e7883a0-5b2e-4317-a0f6-1075c6792fe3.jpg', '2025-10-27');

-- --------------------------------------------------------

--
-- Table structure for table `folder`
--

CREATE TABLE `folder` (
  `folderID` int(11) NOT NULL,
  `userID` int(11) NOT NULL,
  `parentFolderID` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `folderPath` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Dumping data for table `folder`
--

INSERT INTO `folder` (`folderID`, `userID`, `parentFolderID`, `name`, `folderPath`) VALUES
(1, 1, NULL, 'Hello2', NULL),
(2, 1, NULL, 'Yes', NULL);

-- --------------------------------------------------------

--
-- Table structure for table `mindmap`
--

CREATE TABLE `mindmap` (
  `mindmapID` int(11) NOT NULL,
  `fileID` int(11) NOT NULL,
  `title` varchar(500) NOT NULL,
  `data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL CHECK (json_valid(`data`)),
  `imagePath` varchar(500) NOT NULL,
  `createdAt` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- --------------------------------------------------------

--
-- Table structure for table `note`
--

CREATE TABLE `note` (
  `noteID` int(11) DEFAULT NULL,
  `fileID` int(11) NOT NULL,
  `title` varchar(500) NOT NULL,
  `content` longtext NOT NULL,
  `createdAt` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- --------------------------------------------------------

--
-- Table structure for table `summary`
--

CREATE TABLE `summary` (
  `summaryID` int(11) NOT NULL,
  `fileID` int(11) NOT NULL,
  `title` varchar(500) NOT NULL,
  `content` longtext NOT NULL,
  `createdAt` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- --------------------------------------------------------

--
-- Table structure for table `user`
--

CREATE TABLE `user` (
  `userID` int(11) NOT NULL,
  `email` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `username` varchar(255) NOT NULL,
  `profilePic` varchar(255) DEFAULT NULL,
  `isActive` enum('TRUE','FALSE') NOT NULL DEFAULT 'TRUE'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Dumping data for table `user`
--

INSERT INTO `user` (`userID`, `email`, `password`, `username`, `profilePic`, `isActive`) VALUES
(1, 'mantik3333@gmail.com', '$2y$10$D3Qy/R38DWu5EMK5OjHGSebT8WHQVa.Pmd7fBQIpGagUWILvvlwba', 'mantik', NULL, 'TRUE');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `file`
--
ALTER TABLE `file`
  ADD PRIMARY KEY (`fileID`),
  ADD KEY `folderID` (`folderID`),
  ADD KEY `userID` (`userID`);

--
-- Indexes for table `folder`
--
ALTER TABLE `folder`
  ADD PRIMARY KEY (`folderID`),
  ADD KEY `userID` (`userID`);

--
-- Indexes for table `mindmap`
--
ALTER TABLE `mindmap`
  ADD PRIMARY KEY (`mindmapID`);

--
-- Indexes for table `summary`
--
ALTER TABLE `summary`
  ADD PRIMARY KEY (`summaryID`);

--
-- Indexes for table `user`
--
ALTER TABLE `user`
  ADD PRIMARY KEY (`userID`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `file`
--
ALTER TABLE `file`
  MODIFY `fileID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;

--
-- AUTO_INCREMENT for table `folder`
--
ALTER TABLE `folder`
  MODIFY `folderID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- AUTO_INCREMENT for table `mindmap`
--
ALTER TABLE `mindmap`
  MODIFY `mindmapID` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `summary`
--
ALTER TABLE `summary`
  MODIFY `summaryID` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `user`
--
ALTER TABLE `user`
  MODIFY `userID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- Constraints for dumped tables
--

--
-- Constraints for table `file`
--
ALTER TABLE `file`
  ADD CONSTRAINT `file_ibfk_1` FOREIGN KEY (`folderID`) REFERENCES `folder` (`folderID`) ON DELETE CASCADE ON UPDATE CASCADE,
  ADD CONSTRAINT `file_ibfk_2` FOREIGN KEY (`userID`) REFERENCES `user` (`userID`);

--
-- Constraints for table `folder`
--
ALTER TABLE `folder`
  ADD CONSTRAINT `folder_ibfk_1` FOREIGN KEY (`userID`) REFERENCES `user` (`userID`) ON DELETE CASCADE ON UPDATE CASCADE;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
